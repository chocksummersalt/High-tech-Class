"""
파이썬 자료구조 및 알고리즘 구현 문서
- 각 자료구조 및 알고리즘의 설명, 시간 복잡도, 공간 복잡도, 특징 정리
"""

# 자료구조 (Data Structures)

## 1. 스택 (Stack)
- **설명**: 후입선출(LIFO, Last-In-First-Out) 원칙을 따르는 선형 자료구조
- **주요 연산**:
  - push(item): 스택에 요소 추가 - O(1)
  - pop(): 스택에서 요소 제거 및 반환 - O(1)
  - peek(): 스택의 맨 위 요소 반환 (제거하지 않음) - O(1)
  - is_empty(): 스택이 비어있는지 확인 - O(1)
- **시간 복잡도**: 모든 연산 O(1)
- **공간 복잡도**: O(n)
- **특징**:
  - 함수 호출 관리(콜 스택)
  - 괄호 검사, 수식 계산
  - 웹 브라우저 방문 기록
  - 깊이 우선 탐색(DFS) 구현

## 2. 큐 (Queue)
- **설명**: 선입선출(FIFO, First-In-First-Out) 원칙을 따르는 선형 자료구조
- **주요 연산**:
  - enqueue(item): 큐에 요소 추가 - O(1)
  - dequeue(): 큐에서 요소 제거 및 반환 - O(1) (deque 사용 시)
  - peek(): 큐의 맨 앞 요소 반환 (제거하지 않음) - O(1)
  - is_empty(): 큐가 비어있는지 확인 - O(1)
- **시간 복잡도**: 
  - 일반 리스트 사용 시: enqueue O(1), dequeue O(n)
  - collections.deque 사용 시: 모든 연산 O(1)
- **공간 복잡도**: O(n)
- **특징**:
  - 대기열 관리
  - 프로세스 스케줄링
  - 너비 우선 탐색(BFS) 구현
  - 데이터 버퍼링

## 3. 연결 리스트 (Linked List)
- **설명**: 각 노드가 데이터와 다음 노드에 대한 참조를 가지는 선형 자료구조
- **주요 연산**:
  - append(data): 연결 리스트 끝에 노드 추가 - O(1) (tail 포인터 사용 시)
  - prepend(data): 연결 리스트 앞에 노드 추가 - O(1)
  - insert(data, position): 지정된 위치에 노드 삽입 - O(n)
  - remove(data): 데이터를 가진 노드 제거 - O(n)
  - search(data): 데이터를 가진 노드 검색 - O(n)
- **시간 복잡도**:
  - 검색/삽입/삭제: 평균 O(n)
  - 맨 앞/뒤 삽입: O(1)
- **공간 복잡도**: O(n)
- **특징**:
  - 동적 크기 조정
  - 삽입/삭제 효율적
  - 임의 접근 불가능
  - 추가 메모리 사용 (포인터)

## 4. 이진 트리 (Binary Tree)
- **설명**: 각 노드가 최대 두 개의 자식 노드를 가질 수 있는 계층적 자료구조
- **주요 연산**:
  - insert(data): 트리에 새 노드 삽입 - O(log n) ~ O(n)
  - search(data): 트리에서 데이터 검색 - O(log n) ~ O(n)
  - delete(data): 트리에서 노드 삭제 - O(log n) ~ O(n)
  - 순회: 전위(preorder), 중위(inorder), 후위(postorder) - O(n)
- **시간 복잡도**:
  - 균형 트리: 검색/삽입/삭제 O(log n)
  - 불균형 트리: 최악 O(n)
- **공간 복잡도**: O(n)
- **특징**:
  - 계층적 데이터 표현
  - 이진 검색 트리(BST)는 정렬된 데이터 저장
  - 효율적인 검색 가능
  - 균형 유지 필요

## 5. 해시 테이블 (Hash Table)
- **설명**: 키-값 쌍을 저장하는 자료구조로, 해시 함수를 사용하여 키를 배열 인덱스로 변환
- **주요 연산**:
  - insert(key, value): 키-값 쌍 삽입 - O(1) ~ O(n)
  - get(key): 키에 해당하는 값 검색 - O(1) ~ O(n)
  - remove(key): 키-값 쌍 삭제 - O(1) ~ O(n)
  - contains(key): 키 존재 여부 확인 - O(1) ~ O(n)
- **시간 복잡도**:
  - 평균: 삽입/검색/삭제 O(1)
  - 최악: 충돌 발생 시 O(n)
- **공간 복잡도**: O(n)
- **특징**:
  - 빠른 검색/삽입/삭제
  - 충돌 처리 필요 (체이닝, 개방 주소법)
  - 해시 함수 품질에 성능 의존
  - 파이썬의 dict는 해시 테이블로 구현됨

# 탐색 알고리즘 (Search Algorithms)

## 1. 선형 탐색 (Linear Search)
- **설명**: 배열의 각 요소를 순차적으로 확인하여 원하는 값을 찾는 알고리즘
- **시간 복잡도**:
  - 평균: O(n/2)
  - 최악: O(n)
  - 최선: O(1) (첫 번째 요소가 찾는 값인 경우)
- **공간 복잡도**: O(1)
- **특징**:
  - 구현이 간단함
  - 정렬되지 않은 배열에서도 사용 가능
  - 작은 배열에서 효율적
  - 큰 배열에서는 비효율적

## 2. 이진 탐색 (Binary Search)
- **설명**: 정렬된 배열에서 중간 값을 기준으로 탐색 범위를 절반씩 줄여가며 원하는 값을 찾는 알고리즘
- **시간 복잡도**:
  - 평균 및 최악: O(log n)
  - 최선: O(1) (중간 요소가 찾는 값인 경우)
- **공간 복잡도**:
  - 반복적 구현: O(1)
  - 재귀적 구현: O(log n) (재귀 호출 스택)
- **특징**:
  - 정렬된 배열에서만 사용 가능
  - 매우 효율적인 탐색 알고리즘
  - 분할 정복 방식 사용
  - 큰 데이터셋에서 선형 탐색보다 훨씬 빠름

## 3. 깊이 우선 탐색 (DFS, Depth-First Search)
- **설명**: 그래프나 트리에서 한 경로를 끝까지 탐색한 후 다른 경로를 탐색하는 알고리즘
- **시간 복잡도**: O(V + E) (V: 정점 수, E: 간선 수)
- **공간 복잡도**: O(V)
- **구현 방법**:
  - 재귀 사용
  - 스택 사용
- **특징**:
  - 경로 찾기 문제에 적합
  - 위상 정렬에 사용
  - 연결 요소 찾기
  - 사이클 감지
  - 메모리 사용이 BFS보다 적을 수 있음

## 4. 너비 우선 탐색 (BFS, Breadth-First Search)
- **설명**: 그래프나 트리에서 가까운 정점부터 탐색하는 알고리즘
- **시간 복잡도**: O(V + E) (V: 정점 수, E: 간선 수)
- **공간 복잡도**: O(V)
- **구현 방법**: 큐 사용
- **특징**:
  - 최단 경로 찾기에 적합
  - 레벨 순회에 사용
  - 연결 요소 찾기
  - 두 노드 사이의 최소 거리 계산
  - 웹 크롤링, 소셜 네트워크 분석에 활용

# 정렬 알고리즘 (Sorting Algorithms)

## 1. 버블 정렬 (Bubble Sort)
- **설명**: 인접한 두 요소를 비교하여 필요시 교환하는 방식으로 정렬하는 알고리즘
- **시간 복잡도**:
  - 평균 및 최악: O(n²)
  - 최선: O(n) (이미 정렬된 경우)
- **공간 복잡도**: O(1)
- **안정성**: 안정적 (동일한 값의 상대적 순서 유지)
- **특징**:
  - 구현이 매우 간단함
  - 작은 데이터셋에서만 효율적
  - 교환 연산이 많음
  - 최적화: 교환이 일어나지 않으면 이미 정렬된 상태로 종료

## 2. 선택 정렬 (Selection Sort)
- **설명**: 배열에서 최소값을 찾아 맨 앞의 요소와 교환하는 방식으로 정렬하는 알고리즘
- **시간 복잡도**: 항상 O(n²)
- **공간 복잡도**: O(1)
- **안정성**: 불안정 (동일한 값의 상대적 순서가 바뀔 수 있음)
- **특징**:
  - 구현이 간단함
  - 교환 횟수가 버블 정렬보다 적음 (최대 n-1번)
  - 항상 O(n²) 시간 복잡도 (최선의 경우에도 개선되지 않음)
  - 작은 배열에서만 효율적

## 3. 삽입 정렬 (Insertion Sort)
- **설명**: 정렬된 부분과 정렬되지 않은 부분으로 나누어 정렬되지 않은 요소를 정렬된 부분의 적절한 위치에 삽입하는 알고리즘
- **시간 복잡도**:
  - 평균 및 최악: O(n²)
  - 최선: O(n) (이미 정렬된 경우)
- **공간 복잡도**: O(1)
- **안정성**: 안정적 (동일한 값의 상대적 순서 유지)
- **특징**:
  - 작은 데이터셋에서 효율적
  - 이미 정렬된 데이터에 대해 O(n) 시간 복잡도
  - 온라인 알고리즘 (데이터가 들어오는 대로 정렬 가능)
  - 부분적으로 정렬된 배열에서 효율적

## 4. 퀵 정렬 (Quick Sort)
- **설명**: 분할 정복 방식을 사용하는 정렬 알고리즘으로, 피벗을 선택하고 피벗보다 작은 요소와 큰 요소로 분할한 후 재귀적으로 정렬
- **시간 복잡도**:
  - 평균: O(n log n)
  - 최악: O(n²) (이미 정렬된 배열, 피벗 선택이 좋지 않은 경우)
  - 최선: O(n log n)
- **공간 복잡도**: O(log n) (재귀 호출 스택)
- **안정성**: 불안정 (동일한 값의 상대적 순서가 바뀔 수 있음)
- **특징**:
  - 평균적으로 매우 빠른 정렬 알고리즘
  - 추가 메모리 공간을 거의 사용하지 않는 제자리 정렬
  - 피벗 선택이 성능에 큰 영향을 미침
  - 개선 방법: 랜덤 피벗 선택, 세 값의 중앙값을 피벗으로 선택

## 5. 병합 정렬 (Merge Sort)
- **설명**: 분할 정복 방식을 사용하는 정렬 알고리즘으로, 배열을 절반으로 나누고 각각을 정렬한 후 병합하는 방식
- **시간 복잡도**: 항상 O(n log n)
- **공간 복잡도**: O(n)
- **안정성**: 안정적 (동일한 값의 상대적 순서 유지)
- **특징**:
  - 항상 O(n log n) 시간 복잡도 보장 (최악의 경우에도)
  - 연결 리스트 정렬에 효율적
  - 추가 메모리 공간 O(n) 필요
  - 외부 정렬, 병렬 정렬 알고리즘의 기초

## 6. 힙 정렬 (Heap Sort)
- **설명**: 이진 힙 자료구조를 사용하는 정렬 알고리즘으로, 최대 힙을 구성한 후 루트 노드(최댓값)를 배열 끝으로 이동하는 과정을 반복
- **시간 복잡도**: 항상 O(n log n)
- **공간 복잡도**: O(1) (제자리 정렬)
- **안정성**: 불안정 (동일한 값의 상대적 순서가 바뀔 수 있음)
- **특징**:
  - 항상 O(n log n) 시간 복잡도 보장
  - 추가 메모리 공간을 사용하지 않는 제자리 정렬
  - 우선순위 큐 구현에 활용 가능
  - 캐시 지역성이 좋지 않아 실제로는 퀵 정렬이나 병합 정렬보다 느릴 수 있음

# 알고리즘 성능 비교

## 정렬 알고리즘 성능 비교
| 알고리즘 | 최선 시간 복잡도 | 평균 시간 복잡도 | 최악 시간 복잡도 | 공간 복잡도 | 안정성 |
|---------|--------------|--------------|--------------|----------|-------|
| 버블 정렬 | O(n) | O(n²) | O(n²) | O(1) | 안정적 |
| 선택 정렬 | O(n²) | O(n²) | O(n²) | O(1) | 불안정 |
| 삽입 정렬 | O(n) | O(n²) | O(n²) | O(1) | 안정적 |
| 퀵 정렬 | O(n log n) | O(n log n) | O(n²) | O(log n) | 불안정 |
| 병합 정렬 | O(n log n) | O(n log n) | O(n log n) | O(n) | 안정적 |
| 힙 정렬 | O(n log n) | O(n log n) | O(n log n) | O(1) | 불안정 |

## 탐색 알고리즘 성능 비교
| 알고리즘 | 최선 시간 복잡도 | 평균 시간 복잡도 | 최악 시간 복잡도 | 공간 복잡도 | 요구사항 |
|---------|--------------|--------------|--------------|----------|-------|
| 선형 탐색 | O(1) | O(n/2) | O(n) | O(1) | 없음 |
| 이진 탐색 | O(1) | O(log n) | O(log n) | O(1) | 정렬된 배열 |
| DFS | - | O(V + E) | O(V + E) | O(V) | 그래프/트리 |
| BFS | - | O(V + E) | O(V + E) | O(V) | 그래프/트리 |

# 자료구조 및 알고리즘 선택 가이드

## 언제 어떤 자료구조를 사용해야 하는가?
- **스택**: LIFO 접근이 필요할 때, 함수 호출 관리, 괄호 검사, 수식 계산
- **큐**: FIFO 접근이 필요할 때, 대기열 관리, 프로세스 스케줄링, BFS 구현
- **연결 리스트**: 동적 크기 조정이 필요하고 삽입/삭제가 빈번할 때
- **이진 트리**: 계층적 데이터 표현, 효율적인 검색이 필요할 때
- **해시 테이블**: 키-값 쌍 저장, 빠른 검색/삽입/삭제가 필요할 때

## 언제 어떤 탐색 알고리즘을 사용해야 하는가?
- **선형 탐색**: 정렬되지 않은 작은 배열에서 검색할 때
- **이진 탐색**: 정렬된 배열에서 효율적인 검색이 필요할 때
- **DFS**: 경로 찾기, 위상 정렬, 사이클 감지가 필요할 때
- **BFS**: 최단 경로 찾기, 레벨 순회, 두 노드 사이의 최소 거리 계산이 필요할 때

## 언제 어떤 정렬 알고리즘을 사용해야 하는가?
- **버블/선택/삽입 정렬**: 작은 데이터셋, 구현이 간단해야 할 때
- **삽입 정렬**: 거의 정렬된 데이터, 온라인 정렬이 필요할 때
- **퀵 정렬**: 평균적으로 빠른 정렬이 필요하고 추가 메모리 사용을 최소화해야 할 때
- **병합 정렬**: 안정적인 정렬이 필요하거나 최악의 경우에도 성능 보장이 필요할 때
- **힙 정렬**: 제자리 정렬이 필요하고 최악의 경우에도 성능 보장이 필요할 때
